================================================================================================

#Interitance

class B : public A
{
	// 멤버 변수, 함수 선언
}

=> 클래스 B는 클래스 A를 상속받는다

cf. private는 상속이 되지 않지만 
private 멤버에 접근 가능한 메소드를 상속받아 
접근할 수 있음

================================================================================================

#Virture method !!!

if 만약 메서드에 메모리할당 등이 있을 때에는
반드시 virture을 이용하여 메모리 해제가 필요

================================================================================================

#Protected
상속시 나의 Private으로 사용 가능
즉 private는 상속이 안되지만
protected는 상속이 됨(나의 private로 사용 가능)

================================================================================================

#추상화 클래스
가상함수 = 0 (순수 가상 함수 형태)
순수 가상함수가 들어있는 클래스는 추상화 클래스라고 함

상속시, 이런 함수가 있어, 대신 정의는 상속받은 너희가 해 (꼭 재정의 필요)

모든 게 다 순수 가상함수 형태일 때 => 인터페이스 라고 칭함














===================================================================

Q2. n명의 이용자를 가진 소셜 네트워크 서비스가 있다
	각각의 이용자는 1번부터 n번까지 번호가 붙어있다
	이 서비스 네트워크에서 각 이용자의 친구 수를 분석하려고 하다

	이용자 A가 B의 친구라면 B도 A의 친구이다.
	이때, 친구의 친구도 친구이다. 
	따라서 A와 B가 친구관계이고, B와 C가 친구관계라면 A와 C도 친구이다.

	소셜 네트워크의 전체 이용자수 N, 각 이용자의 친구관계를 담고 있는 배열
	Relation이 매개변수로 주어질 때, 각 이용자의 친구수를 1번 이용자부터
	순서대로 담은 배열을 return하도록 Solution함수를 완성하라

	제한사항 : 
		- n은 2이상 100이하의 자연수
		- relation의 각 원소는 친구관계를 나타내며, relation 의 길이는
			1이상 n(n-1)/2이하
		- 각 친구 관계는 길이가 2인 배열이며, 순서대로 (a, b)로 나타낸다.
			a, b (1<=a, b<=n, a!=b)는 친구 관계인 두 이용자의 번호
		- a와 b가 같은 경우는 없으며, 친구관계는 한번씩만 주어진다.

		- 10000ms (10초 내 작동 완료) - 클럭함수

===================================================================

Q1. 하노이탑 
			

a b c

hanoi (n, from, via, to)

if (n>1)
	Hanoi(n-1, from, to, via)

// n == n
	from -> to

// n - 1
if (n>1)
	Hanoi(n-1, via, from, to)

===================================================================

Q2. 퀸은 상, 하, 좌, 우, 대각선으로 기물이 없는 칸에 대해 제한 없이
	이동 가능하다. 8X8에 8개의 퀸이 서로 충돌하지 않고 위치할 수 있는 
	경우의 수를 만들고, 해당 조합을 □ ■ 을 사용해서 각 배치 상황을 출력하라.
	이후 속도 확인




위치할 수 없는 타일 : 현재 말이 있는 타일의 가로, 세로, 대각선



for문을 칸의 수만큼 돌려 i에 말을 위치 시킴

for (int i = 0; i < 64; ++i)
{
	1Q의 위치 = i

	1Q의 위치에서 가로, 세로, 대각선 제거 후, 가장 낮은 수에 2Q을 위치		=>		

	2Q의 위치에서 가로, 세로, 대각선 제거 후, 가장 낮은 수에 3Q을 위치

	3Q의 위치에서 가로, 세로, 대각선 제거 후, 가장 낮은 수에 4Q을 위치

	(만약 위치할 수 없다면 continue)



	8Q까지 성공했다면 => 2Q의 위치를 한칸 옆으로(가능한 위치상)
	   				 => 3Q의 위치를 한칸 옆으로(가능한 위치상)
	......
}






int col = sizeof(numArr[0]) / sizeof(int);    // 4: 2차원 배열의 가로 크기를 구할 때는 
                                                  // 가로 한 줄의 크기를 요소의 크기로 나눠줌

int row = sizeof(numArr) / sizeof(numArr[0]); // 3: 2차원 배열의 세로 크기를 구할 때는 
												// 배열이 차지하는 전체 공간을 가로 한 줄의 크기로 나눠줌